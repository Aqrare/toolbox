"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Resolver = void 0;
const resolver_provider_router_1 = require("../resolver-providers/resolver-provider-router");
class Resolver {
    constructor(resolverProviders) {
        this._resolverProviderRouter = new resolver_provider_router_1.ResolverProviderRouter(resolverProviders);
    }
    /**
     * Set the order in which the resolver providers are interrogated to resolve a name or tokenId.
     * @param priority the new priority of the providers.
     */
    setResolversPriority(priority) {
        this._resolverProviderRouter.setResolverProvidersPriority(priority);
    }
    /**
     * Adds resolver providers to the Resolver.
     * @param resolverProviders the resolver providers to add.
     */
    addResolverProviders(resolverProviders) {
        this._resolverProviderRouter.addResolverProviders(resolverProviders);
    }
    /**
     * Resolve the given domain fullname or tld.
     * If the domain is valid, exists on the blockchain and can be resolved a `IResolvedResource` is given, otherwise the result is `undefined`.
     * To obtain the resolved resource a series of calls to the blockchain are made, depending on the chain traffic the `resolve` call can take a couple of seconds to be completed.
     * @param domainOrTld the domain to resolve. Eg. `"test.web3domain"`
     * @returns an `IResolvedResource` instance or `undefined`.
     */
    async resolve(domainOrTld) {
        const resolverProvider = this._resolverProviderRouter.getResolverProviderByDomainOrTld(domainOrTld);
        if (resolverProvider) {
            return await resolverProvider.resolve(domainOrTld);
        }
        return undefined;
    }
    /**
     * Resolves the given tokenId.
     * If the tokenId is valid, exists on the blockchain and can be resolved a `IResolvedResource` is given, otherwise the result is `undefined`.
     * To obtain the resolved resource a series of calls to the blockchain are made, depending on the chain traffic the `resolveFromTokenId` call can take a couple of seconds to be completed.
     * To speed up the resolution a `ResolverName` can be provided, in this case only the given provider is checked.
     * @param tokenId the NFT tokenId uint256 string rappresentation to resolve
     * @param resolverProviderName the provider of the tokenId to resolve
     * @returns an `IResolvedResource` instance or `undefined`.
     */
    async resolveFromTokenId(tokenId, resolverProviderName) {
        let resolverProvider;
        if (resolverProviderName) {
            resolverProvider = this._resolverProviderRouter.getResolverProvider(resolverProviderName);
        }
        else {
            resolverProvider = await this._resolverProviderRouter.findTokenIdResolverProvider(tokenId);
        }
        if (resolverProvider) {
            return resolverProvider.resolveFromTokenId(tokenId);
        }
        return undefined;
    }
    /**
     *
     * @param address
     * @param resolverProviderName
     * @returns
     */
    async reverseResolve(address, resolverProviderName) {
        if (resolverProviderName) {
            const resolverProvider = this._resolverProviderRouter.getResolverProvider(resolverProviderName);
            if (!resolverProvider) {
                return undefined;
            }
            const tokenId = await resolverProvider.reverseResolve(address);
            if (tokenId) {
                return await this.resolveFromTokenId(tokenId, resolverProvider.name);
            }
        }
        else {
            for (const resolverProvider of this._resolverProviderRouter.resolverProviders) {
                const tokenId = await resolverProvider.reverseResolve(address);
                if (tokenId) {
                    return await this.resolveFromTokenId(tokenId, resolverProvider.name);
                }
            }
        }
        return undefined;
    }
}
exports.Resolver = Resolver;

"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.FreenameResolverProvider = void 0;
const ethers_1 = require("ethers");
const lodash_clonedeep_1 = __importDefault(require("lodash.clonedeep"));
const default_connections_1 = require("../../../defaults/default-connections");
const contract_connection_1 = require("../../../networks/connections/contract-connection");
const resolver_name_1 = require("../../../resolvers/types/resolver-name");
const base_resolver_provider_1 = require("../base-resolver-provider");
const freename_resolver_provider_consts_1 = require("./freename-resolver-provider.consts");
const freename_resolver_tools_1 = require("./freename-resolver-tools");
class FreenameResolverProvider extends base_resolver_provider_1.BaseResolverProvider {
    constructor(options) {
        const { connectionLibrary, testMode = false } = options;
        const readContractConnections = [];
        const writeContractConnections = [];
        const freenameContractConfs = (0, lodash_clonedeep_1.default)(freename_resolver_provider_consts_1.FREENAME_CONTRACT_CONFS);
        for (const contractConf of freenameContractConfs) {
            if (contractConf.test == testMode) {
                const connection = connectionLibrary?.getConnection(contractConf.networkName) || default_connections_1.DefaultTools.getDefaultConnection(contractConf.networkName, { infuraIfAvailable: true });
                if (contractConf.type == "read") {
                    readContractConnections.push(new contract_connection_1.ContractConnection(connection, contractConf.address, contractConf.abi));
                }
                else if (contractConf.type == "write") {
                    writeContractConnections.push(new contract_connection_1.ContractConnection(connection, contractConf.address, contractConf.abi));
                }
            }
        }
        super(resolver_name_1.ProviderName.FREENAME, ["*"], readContractConnections, writeContractConnections);
    }
    async getRecord(tokenId, key, network) {
        const readContractConnection = await this.getReadContractConnectionFromToken(tokenId, network);
        if (!readContractConnection) {
            return undefined;
        }
        try {
            return await readContractConnection.contract.getRecord(key, tokenId);
        }
        catch {
            return undefined;
        }
    }
    async getManyRecords(tokenId, keys, network) {
        const readContractConnection = await this.getReadContractConnectionFromToken(tokenId, network);
        if (!readContractConnection) {
            return undefined;
        }
        try {
            return await readContractConnection.contract.getManyRecords(keys, tokenId);
        }
        catch {
            return undefined;
        }
    }
    async setRecord(resource, key, value, signer) {
        const writeContract = this.getWriteContractWithSigner(resource.network, signer);
        if (!writeContract) {
            return false;
        }
        try {
            const tx = await writeContract.setRecord(key, value, resource.tokenId);
            const approveReceipt = await tx.wait();
            if (approveReceipt) {
                return true;
            }
            return false;
        }
        catch (e) {
            return false;
        }
    }
    async setRecords(resource, keys, values, signer) {
        const writeContract = this.getWriteContractWithSigner(resource.network, signer);
        if (!writeContract) {
            return false;
        }
        try {
            const tx = await writeContract.setManyRecords(keys, values, resource.tokenId);
            const approveReceipt = await tx.wait();
            if (approveReceipt) {
                return true;
            }
            return false;
        }
        catch (e) {
            return false;
        }
    }
    async generateTokenId(mappedName) {
        let fullnameKeccak;
        if (mappedName.domain) {
            const domainKeccak = ethers_1.ethers.utils.solidityKeccak256(["string"], [mappedName.domain]);
            fullnameKeccak = ethers_1.ethers.utils.solidityKeccak256(["string", "uint256"], [mappedName.tld, domainKeccak]);
        }
        else {
            fullnameKeccak = ethers_1.ethers.utils.solidityKeccak256(["string"], [mappedName.tld]);
        }
        if (fullnameKeccak) {
            const tokenId = ethers_1.ethers.BigNumber.from(fullnameKeccak).toString();
            return tokenId;
        }
        return undefined;
    }
    async getNetworkFromName(mappedName) {
        const tokenId = await this.generateTokenId(mappedName);
        if (!tokenId) {
            return undefined;
        }
        const metadata = await this.getMetadata(tokenId);
        const network = freename_resolver_tools_1.FreenameResolverTools.networkNameFormFreenameNetwork(metadata?.network);
        return network;
    }
    async getRecords(tokenId, network) {
        const keys = await this.getAllRecordKeys(tokenId, network);
        if (!keys) {
            return undefined;
        }
        const values = await this.getManyRecords(tokenId, keys, network);
        if (!values) {
            return undefined;
        }
        if (keys.length !== values.length) {
            return undefined;
        }
        const records = {};
        for (let i = 0; i < keys.length; i++) {
            const key = keys[i];
            records[key] = values[i];
        }
        return records;
    }
    async getAllRecordKeys(tokenId, network) {
        const readContractConnection = await this.getReadContractConnectionFromToken(tokenId, network);
        if (!readContractConnection) {
            return undefined;
        }
        try {
            return await readContractConnection.contract.getAllKeys(tokenId);
        }
        catch {
            return undefined;
        }
    }
    async getNameFromTokenId(tokenId, network) {
        const metadata = await this.getMetadata(tokenId);
        return metadata?.name;
    }
}
exports.FreenameResolverProvider = FreenameResolverProvider;

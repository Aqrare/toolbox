"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BaseResolverProvider = void 0;
const resolved_resource_1 = require("../../resolvers/resolved-resource/resolved-resource");
const api_caller_1 = require("../../tools/api-caller");
const name_tools_1 = require("../../tools/name-tools");
class BaseResolverProvider {
    constructor(name, supportedTlds, readContractConnections, writeContractConnections) {
        this._name = name;
        this._supportedTlds = supportedTlds;
        this._readContractConnections = readContractConnections;
        this._writeContractConnections = writeContractConnections;
    }
    get supportedNetworks() {
        return this._readContractConnections.map(x => x.network);
    }
    get writeContractConnections() {
        return this._writeContractConnections;
    }
    set writeContractConnections(value) {
        this._writeContractConnections = value;
    }
    get readContractConnections() {
        return this._readContractConnections;
    }
    set readContractConnections(value) {
        this._readContractConnections = value;
    }
    get connectionLibrary() {
        return this._connectionLibrary;
    }
    set connectionLibrary(value) {
        this._connectionLibrary = value;
    }
    get name() {
        return this._name;
    }
    set name(value) {
        this._name = value;
    }
    get supportedTlds() {
        return this._supportedTlds;
    }
    set supportedTlds(value) {
        this._supportedTlds = value;
    }
    getReadContractConnection(networkName) {
        return this.readContractConnections.find(x => x.network == networkName);
    }
    getWriteContractConnection(networkName) {
        return this.writeContractConnections.find(x => x.network == networkName);
    }
    getWriteContractWithSigner(networkName, signer) {
        const writeContractConnection = this.getWriteContractConnection(networkName);
        if (!writeContractConnection) {
            return undefined;
        }
        let signerToUse = signer;
        if (!signer.provider) {
            signerToUse = signer.connect(writeContractConnection.provider);
        }
        const contractConnected = writeContractConnection.contract.connect(signerToUse);
        return contractConnected;
    }
    async resolve(domainOrTld) {
        try {
            const mappedName = name_tools_1.NameTools.mapName(domainOrTld);
            if (!mappedName) {
                return undefined;
            }
            const tokenId = await this.generateTokenId(mappedName);
            const network = await this.getNetworkFromName(mappedName);
            if (!tokenId) {
                return undefined;
            }
            return this.generateResolvedResource(mappedName, tokenId, network);
        }
        catch {
            return undefined;
        }
    }
    async resolveFromTokenId(tokenId, network) {
        try {
            const name = await this.getNameFromTokenId(tokenId, network);
            if (!name) {
                return undefined;
            }
            const mappedName = name_tools_1.NameTools.mapName(name);
            if (!mappedName) {
                return undefined;
            }
            return this.generateResolvedResource(mappedName, tokenId, network);
        }
        catch {
            return undefined;
        }
    }
    async reverseResolve(address, network) {
        let readContracts = [];
        if (network) {
            const readContract = this.getReadContractConnection(network);
            if (readContract) {
                readContracts.push(readContract);
            }
        }
        else {
            readContracts = this.readContractConnections;
        }
        for (const readContractConnection of readContracts) {
            try {
                const reverseOfRes = await readContractConnection.contract.reverseOf(address);
                if (reverseOfRes) {
                    const tokenId = reverseOfRes.toString();
                    if (tokenId !== "0") {
                        return tokenId;
                    }
                }
            }
            catch (e) {
                continue;
            }
        }
        return undefined;
    }
    async getTokenUri(tokenId, network) {
        const readContractConnection = await this.getReadContractConnectionFromToken(tokenId, network);
        if (!readContractConnection) {
            return undefined;
        }
        try {
            return await readContractConnection.contract.tokenURI(tokenId);
        }
        catch {
            return undefined;
        }
    }
    async getMetadata(tokenId, network) {
        const tokenUri = await this.getTokenUri(tokenId, network);
        if (!tokenUri) {
            return undefined;
        }
        try {
            return api_caller_1.ApiCaller.getHttpsCall(tokenUri);
        }
        catch {
            return undefined;
        }
    }
    async getImageUrl(tokenId, network) {
        const metadata = await this.getMetadata(tokenId, network);
        return metadata?.image;
    }
    async exists(tokenId, network) {
        const readContractConnection = await this.getReadContractConnectionFromToken(tokenId, network);
        if (!readContractConnection) {
            return false;
        }
        try {
            return await readContractConnection.contract.exists(tokenId);
        }
        catch {
            return false;
        }
    }
    async getOwnerAddress(tokenId, network) {
        const readContractConnection = await this.getReadContractConnectionFromToken(tokenId, network);
        if (!readContractConnection) {
            return undefined;
        }
        try {
            return await readContractConnection.contract.ownerOf(tokenId);
        }
        catch {
            return undefined;
        }
    }
    async isApprovedOrOwner(tokenId, addressToCheck, network) {
        const readContractConnection = await this.getReadContractConnectionFromToken(tokenId, network);
        if (!readContractConnection) {
            return false;
        }
        try {
            return await readContractConnection.contract.isApprovedOrOwner(tokenId, addressToCheck);
        }
        catch {
            return false;
        }
    }
    async getRecord(tokenId, key, network) {
        const readContractConnection = await this.getReadContractConnectionFromToken(tokenId, network);
        if (!readContractConnection) {
            return undefined;
        }
        try {
            return await readContractConnection.contract.get(key, tokenId);
        }
        catch {
            return undefined;
        }
    }
    async getManyRecords(tokenId, keys, network) {
        const readContractConnection = await this.getReadContractConnectionFromToken(tokenId, network);
        if (!readContractConnection) {
            return undefined;
        }
        try {
            return await readContractConnection.contract.getMany(keys, tokenId);
        }
        catch {
            return undefined;
        }
    }
    async transfer(resource, addressTo, signer) {
        const writeContract = this.getWriteContractWithSigner(resource.network, signer);
        if (!writeContract) {
            return false;
        }
        try {
            const tx = await writeContract.transferFrom(resource.ownerAddress, addressTo, resource.tokenId);
            const approveReceipt = await tx.wait();
            if (approveReceipt) {
                return true;
            }
            return false;
        }
        catch (e) {
            return false;
        }
    }
    async setApproved(resource, addessToApprove, signer) {
        const writeContract = this.getWriteContractWithSigner(resource.network, signer);
        if (!writeContract) {
            return false;
        }
        try {
            const tx = await writeContract.approve(addessToApprove, resource.tokenId);
            const approveReceipt = await tx.wait();
            if (approveReceipt) {
                return true;
            }
            return false;
        }
        catch (e) {
            return false;
        }
    }
    async setRecord(resource, key, value, signer) {
        const writeContract = this.getWriteContractWithSigner(resource.network, signer);
        if (!writeContract) {
            return false;
        }
        try {
            const tx = await writeContract.set(key, value, resource.tokenId);
            const approveReceipt = await tx.wait();
            if (approveReceipt) {
                return true;
            }
            return false;
        }
        catch (e) {
            return false;
        }
    }
    async setRecords(resource, keys, values, signer) {
        const writeContract = this.getWriteContractWithSigner(resource.network, signer);
        if (!writeContract) {
            return false;
        }
        try {
            const tx = await writeContract.setMany(keys, values, resource.tokenId);
            const approveReceipt = await tx.wait();
            if (approveReceipt) {
                return true;
            }
            return false;
        }
        catch (e) {
            return false;
        }
    }
    async setReverse(resource, signer) {
        const writeContract = this.getWriteContractWithSigner(resource.network, signer);
        if (!writeContract) {
            return false;
        }
        try {
            const tx = await writeContract.setReverse(resource.tokenId);
            const approveReceipt = await tx.wait();
            if (approveReceipt) {
                return true;
            }
            return false;
        }
        catch (e) {
            return false;
        }
    }
    async generateResolvedResource(mappedName, tokenId, network) {
        const readContractConnection = await this.getReadContractConnectionFromToken(tokenId, network);
        if (!readContractConnection) {
            return undefined;
        }
        const writeContractConnection = await this.getWriteContractConnection(readContractConnection.network);
        if (!writeContractConnection) {
            return undefined;
        }
        const exists = await this.exists(tokenId, readContractConnection.network);
        if (!exists) {
            return undefined;
        }
        const ownerAddress = await this.getOwnerAddress(tokenId, readContractConnection.network);
        if (!ownerAddress) {
            return undefined;
        }
        const tokenUri = await this.getTokenUri(tokenId, readContractConnection.network);
        const metadata = await this.getMetadata(tokenId, readContractConnection.network);
        const records = await this.getRecords(tokenId, readContractConnection.network);
        const resolverResourceType = name_tools_1.NameTools.getResolvedResourceType(mappedName.type);
        const resolvedResource = new resolved_resource_1.ResolvedResource({
            fullname: mappedName.fullname,
            tld: mappedName.tld,
            type: resolverResourceType,
            tokenId: tokenId,
            resolverName: this._name,
            resolverProvider: this,
            imageUrl: metadata?.image_url,
            metadataUri: tokenUri,
            network: readContractConnection.network,
            ownerAddress: ownerAddress,
            proxyReaderAddress: readContractConnection.address,
            proxyWriterAddress: writeContractConnection.address,
            domain: mappedName.domain,
            metadata: metadata,
            records: records,
        });
        return resolvedResource;
    }
    async getTokenIdNetwork(tokenId) {
        for (const readContractConnection of this.readContractConnections) {
            const exists = await readContractConnection.contract.exists(tokenId);
            if (exists) {
                return readContractConnection.network;
            }
        }
    }
    async getReadContractConnectionFromToken(tokenId, network) {
        let networkToUse = network;
        if (!network) {
            networkToUse = await this.getTokenIdNetwork(tokenId);
        }
        if (!networkToUse) {
            return undefined;
        }
        const readContractConnection = this.getReadContractConnection(networkToUse);
        if (!readContractConnection) {
            return undefined;
        }
        return readContractConnection;
    }
}
exports.BaseResolverProvider = BaseResolverProvider;

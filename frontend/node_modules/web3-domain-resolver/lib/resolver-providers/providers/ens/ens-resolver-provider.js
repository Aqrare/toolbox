"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ENSResolverProvider = void 0;
const network_connection_types_1 = require("../../../networks/connections/network-connection.types");
const resolver_name_1 = require("../../../resolvers/types/resolver-name");
const base_resolver_provider_1 = require("../base-resolver-provider");
const ens_resolver_provider_consts_1 = require("./ens-resolver-provider.consts");
const contract_connection_1 = require("../../../networks/connections/contract-connection");
const ethers_1 = require("ethers");
const api_caller_1 = require("../../../tools/api-caller");
const default_connections_1 = require("../../../defaults/default-connections");
const name_tools_1 = require("../../../tools/name-tools");
class ENSResolverProvider extends base_resolver_provider_1.BaseResolverProvider {
    constructor(options = {}) {
        const ethConnection = options.connectionLibrary?.getConnection(network_connection_types_1.NetworkName.ETHEREUM) || default_connections_1.DefaultTools.getDefaultConnection(network_connection_types_1.NetworkName.ETHEREUM);
        const ensContract = new contract_connection_1.ContractConnection(ethConnection, ens_resolver_provider_consts_1.ENS_CONTRACT_ADDRESS, ens_resolver_provider_consts_1.ENS_ABI);
        super(resolver_name_1.ProviderName.ENS, ens_resolver_provider_consts_1.ENS_SUPPORTED_TLDS, [ensContract], [ensContract]);
    }
    async reverseResolve(address, network) {
        let readContracts = [];
        if (network) {
            const readContract = this.getReadContractConnection(network);
            if (readContract) {
                readContracts.push(readContract);
            }
        }
        else {
            readContracts = this.readContractConnections;
        }
        for (const readContractConnection of readContracts) {
            try {
                const ensName = await readContractConnection.provider.lookupAddress(address);
                if (ensName) {
                    const mappedName = name_tools_1.NameTools.mapName(ensName);
                    if (!mappedName) {
                        return undefined;
                    }
                    const tokenId = await this.generateTokenId(mappedName);
                    if (!tokenId) {
                        return undefined;
                    }
                    const owner = await this.getOwnerAddress(tokenId, network);
                    if (!owner) {
                        return undefined;
                    }
                    //check https://docs.ens.domains/dapp-developer-guide/resolving-names#reverse-resolution
                    if (owner !== address) {
                        return undefined;
                    }
                    return tokenId;
                }
            }
            catch (e) {
                continue;
            }
        }
        return undefined;
    }
    async exists(tokenId, network) {
        const readContractConnection = await super.getReadContractConnectionFromToken(tokenId, network);
        if (!readContractConnection) {
            return false;
        }
        try {
            const res = await readContractConnection.contract.available(tokenId);
            return !res;
        }
        catch {
            return false;
        }
    }
    async generateTokenId(mappedName) {
        if (!mappedName.domain) {
            return undefined;
        }
        try {
            const labelHash = ethers_1.ethers.utils.keccak256(ethers_1.ethers.utils.toUtf8Bytes(mappedName.domain));
            const tokenId = ethers_1.ethers.BigNumber.from(labelHash).toString();
            return tokenId;
        }
        catch {
            return undefined;
        }
    }
    async getTokenUri(tokenId, network) {
        //There is no token uri https://docs.ens.domains/dapp-developer-guide/ens-as-nft#metadata
        return undefined;
    }
    async getMetadata(tokenId, network) {
        const readContractConnection = await super.getReadContractConnectionFromToken(tokenId, network);
        if (!readContractConnection) {
            return false;
        }
        //https://metadata.ens.domains/docs
        const metadataUrl = ens_resolver_provider_consts_1.ENS_MAINNET_METADATA_URL + readContractConnection.address + "/" + tokenId;
        return api_caller_1.ApiCaller.getHttpsCall(metadataUrl);
    }
    async getNetworkFromName(mappedName) {
        return network_connection_types_1.NetworkName.ETHEREUM;
    }
    async getRecords(tokenId) {
        return undefined;
    }
    async getNameFromTokenId(tokenId, network) {
        const metadata = await this.getMetadata(tokenId, network);
        return metadata?.name;
    }
    async setRecord(resource, key, value, signer) {
        return false;
    }
    async getManyRecords(tokenId, keys, network) {
        return undefined;
    }
    async getTokenIdNetwork(tokenId) {
        for (const readContractConnection of this.readContractConnections) {
            try {
                const res = await readContractConnection.contract.available(tokenId);
                if (!res) {
                    return readContractConnection.network;
                }
            }
            catch {
                continue;
            }
        }
    }
}
exports.ENSResolverProvider = ENSResolverProvider;
